from pathlib import Path
path = Path(r"e:\Personal\important\Nexus_LMS\web\pages\student\Classes.tsx")
text = path.read_text()
original = text
text = text.replace("import React, { useMemo, useState, useEffect } from 'react';", "import React, { useState, useEffect } from 'react';")
text = text.replace("type EnrolledClass = {\n    id: string;\n    title: string;\n    subject: string;\n    teacherName: string;\n};", "type EnrolledClass = {\n    id: string;\n    title: string;\n    subject: string;\n    teacherName: string;\n    nextSession?: string | null;\n};")
text = text.replace("    const [enrolledClasses, setEnrolledClasses] = useState<EnrolledClass[]>([]);\n    const [loading, setLoading] = useState(true);\n    const [error, setError] = useState<string | null>(null);\n\n    useEffect(() => {", "    const [enrolledClasses, setEnrolledClasses] = useState<EnrolledClass[]>([]);\n    const [loading, setLoading] = useState(true);\n    const [error, setError] = useState<string | null>(null);\n\n    const formatNextSession = (iso?: string | null) => {\n        if (!iso) {\n            return 'Not scheduled yet';\n        }\n\n        return new Date(iso).toLocaleString(undefined, {\n            dateStyle: 'medium',\n            timeStyle: 'short',\n        });\n    };\n\n    useEffect(() => {")
old_block = "                const [mySessions, groups, pairs] = await Promise.all([\r\n                    api.getMySessions(),\r\n                    api.getMyEnrolledGroups(),\r\n                    api.getMyEnrolledPairs(),\r\n                ]);\r\n\r\n                const enrolledClassIds = new Set<string>();\r\n                mySessions.forEach((session: Session) => enrolledClassIds.add(session.classId));\r\n\r\n                const mappedGroups = groups\r\n                    .filter((g: Group) => enrolledClassIds.has(g.id))\r\n                    .map((g: Group) => ({\r\n                        id: g.id,\r\n                        title: g.title,\r\n                        subject: g.subject,\r\n                        teacherName: g.teacher?.name || 'N/A',\r\n                    }));\r\n\r\n                const mappedPairs = pairs\r\n                    .filter((p: OneToOne) => enrolledClassIds.has(p.id))\r\n                    .map((p: OneToOne) => ({\r\n                        id: p.id,\r\n                        title: p.title,\r\n                        subject: p.subject,\r\n                        teacherName: p.teacher?.name || 'N/A',\r\n                    }));\r\n\r\n                setEnrolledClasses([...mappedGroups, ...mappedPairs]);"
new_block = "                const [mySessions, groups, pairs] = await Promise.all([\n                    api.getMySessions(),\n                    api.getMyEnrolledGroups(),\n                    api.getMyEnrolledPairs(),\n                ]);\n\n                const nextSessionByClass = new Map<string, Session>();\n                mySessions.forEach((session: Session) => {\n                    const current = nextSessionByClass.get(session.classId);\n                    if (!current || new Date(session.startsAt) < new Date(current.startsAt)) {\n                        nextSessionByClass.set(session.classId, session);\n                    }\n                });\n\n                const mappedGroups = groups.map((g: Group) => ({\n                    id: g.id,\n                    title: g.title,\n                    subject: g.subject,\n                    teacherName: g.teacher?.name || 'N/A',\n                    nextSession: nextSessionByClass.get(g.id)?.startsAt ?? null,\n                }));\n\n                const mappedPairs = pairs.map((p: OneToOne) => ({\n                    id: p.id,\n                    title: p.title,\n                    subject: p.subject,\n                    teacherName: p.teacher?.name || 'N/A',\n                    nextSession: nextSessionByClass.get(p.id)?.startsAt ?? null,\n                }));\n\n                const combined = [...mappedGroups, ...mappedPairs].sort((a, b) => {\n                    const aTime = a.nextSession ? new Date(a.nextSession).getTime() : Number.POSITIVE_INFINITY;\n                    const bTime = b.nextSession ? new Date(b.nextSession).getTime() : Number.POSITIVE_INFINITY;\n\n                    if (aTime != bTime) {\n                        return aTime - bTime;\n                    }\n\n                    return a.title.localeCompare(b.title);\n                });\n\n                setEnrolledClasses(combined);"
if old_block not in text:
    raise SystemExit('Old block not found')
text = text.replace(old_block, new_block)
text = text.replace("                <div className=\"my-4 text-sm bg-base-200/30 p-3 rounded-md\">\r\n                    <p>\r\n                        <strong>Teacher:</strong> {c.teacherName}\r\n                    </p>\r\n                </div>", "                <div className=\"my-4 text-sm bg-base-200/30 p-3 rounded-md space-y-2\">\n                    <p>\n                        <strong>Teacher:</strong> {c.teacherName}\n                    </p>\n                    <p className=\"text-xs text-gray-500\">\n                        Next session: {formatNextSession(c.nextSession)}\n                    </p>\n                </div>")
if text == original:
    raise SystemExit('No changes applied')
path.write_text(text)
